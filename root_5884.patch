From 2df65f90d8b3e2e9a426000a011d1475df0e78b2 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Wed, 17 Jun 2020 05:34:13 +0000
Subject: [PATCH 1/7] Properly check if environment variable boolean values.

Environment variables can be set to 1, On, TRUE and 0, Off, FALSE to set a bool
value. Implement a FoundationUtils facility to check for it.
---
 cmake/modules/RootMacros.cmake                | 15 ++++--
 core/foundation/res/ROOT/FoundationUtils.hxx  |  9 +++-
 core/foundation/src/FoundationUtils.cxx       | 28 ++++++++++
 core/foundation/test/CMakeLists.txt           |  1 +
 core/foundation/test/FoundationUtilsTests.cxx | 51 +++++++++++++++++++
 core/metacling/src/TCling.cxx                 | 11 ++--
 6 files changed, 108 insertions(+), 7 deletions(-)
 create mode 100644 core/foundation/test/FoundationUtilsTests.cxx

diff --git a/cmake/modules/RootMacros.cmake b/cmake/modules/RootMacros.cmake
index 5f9f529e5b6..085612dff23 100644
--- a/cmake/modules/RootMacros.cmake
+++ b/cmake/modules/RootMacros.cmake
@@ -1652,10 +1652,15 @@ function(ROOT_ADD_UNITTEST_DIR)
 endfunction()
 
 #----------------------------------------------------------------------------
-# function ROOT_ADD_GTEST(<testsuite> source1 source2... COPY_TO_BUILDDIR file1 file2 LIBRARIES)
-#
+# function ROOT_ADD_GTEST(<testsuite> source1 source2...
+#                        [WILLFAIL]
+#                        [COPY_TO_BUILDDIR file1 file2...] -- files to copy in the build directory
+#                        [LIBRARIES lib1 lib2...] -- Libraries to link against
+#                        [LABELS label1 label2...]) -- Labels to annotate the test
+#                        [INCLUDE_DIRS label1 label2...]) -- Extra target include directories
+
 function(ROOT_ADD_GTEST test_suite)
-  CMAKE_PARSE_ARGUMENTS(ARG "WILLFAIL" "" "COPY_TO_BUILDDIR;LIBRARIES;LABELS" ${ARGN})
+  CMAKE_PARSE_ARGUMENTS(ARG "WILLFAIL" "" "COPY_TO_BUILDDIR;LIBRARIES;LABELS;INCLUDE_DIRS" ${ARGN})
 
   # ROOTUnitTestSupport
   if(NOT TARGET ROOTUnitTestSupport)
@@ -1672,6 +1677,10 @@ function(ROOT_ADD_GTEST test_suite)
   ROOT_EXECUTABLE(${test_suite} ${source_files} LIBRARIES ${ARG_LIBRARIES})
   target_link_libraries(${test_suite} gtest gtest_main gmock gmock_main ROOTUnitTestSupport)
   target_include_directories(${test_suite} PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
+  if (ARG_INCLUDE_DIRS)
+    target_include_directories(${test_suite} PRIVATE ${ARG_INCLUDE_DIRS})
+  endif(ARG_INCLUDE_DIRS)
+
   if(MSVC)
     set(test_exports "/EXPORT:_Init_thread_abort /EXPORT:_Init_thread_epoch
         /EXPORT:_Init_thread_footer /EXPORT:_Init_thread_header /EXPORT:_tls_index")
diff --git a/core/foundation/res/ROOT/FoundationUtils.hxx b/core/foundation/res/ROOT/FoundationUtils.hxx
index 72ef1ad17f0..ce224f10671 100644
--- a/core/foundation/res/ROOT/FoundationUtils.hxx
+++ b/core/foundation/res/ROOT/FoundationUtils.hxx
@@ -9,7 +9,7 @@
 /// \date June, 2019
 ///
 /*************************************************************************
- * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.               *
+ * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers.               *
  * All rights reserved.                                                  *
  *                                                                       *
  * For the licensing terms see $ROOTSYS/LICENSE.                         *
@@ -74,6 +74,13 @@ namespace FoundationUtils {
    ///\returns the sysconfig directory in the installation.
    const std::string& GetEtcDir();
 
+   ///\returns true if lowercase \c value is 1, on, true, 0, off, false
+   bool CanConvertEnvValueToBool(const std::string& value);
+
+   ///\returns true if the lowercase string is 1, on, true; false if 0, off,
+   /// false
+   bool ConvertEnvValueToBool(const std::string& value);
+
    } // namespace FoundationUtils
 } // namespace ROOT
 
diff --git a/core/foundation/src/FoundationUtils.cxx b/core/foundation/src/FoundationUtils.cxx
index 9de395698b6..e6de46c6878 100644
--- a/core/foundation/src/FoundationUtils.cxx
+++ b/core/foundation/src/FoundationUtils.cxx
@@ -21,6 +21,7 @@
 #include <RConfigure.h>
 
 #include <algorithm>
+#include <cassert>
 
 #include <errno.h>
 #include <string.h>
@@ -178,5 +179,32 @@ const std::string& GetEtcDir() {
    return rootetcdir;
 }
 
+static std::string str_tolower(std::string s) {
+   std::transform(s.begin(), s.end(), s.begin(),
+                  [](unsigned char c){ return std::tolower(c); });
+   return s;
+}
+
+bool CanConvertEnvValueToBool(const std::string& value) {
+   std::string lowercase = str_tolower(value);
+   if (lowercase == "1" || lowercase == "on" || lowercase == "true")
+      return true;
+   if (lowercase == "0" || lowercase == "off" || lowercase == "false")
+      return true;
+
+   return false;
+}
+
+bool ConvertEnvValueToBool(const std::string& value) {
+   assert(CanConvertEnvValueToBool(value));
+   std::string lowercase = str_tolower(value);
+   if (lowercase == "1" || lowercase == "on" || lowercase == "true")
+      return true;
+   if (lowercase == "0" || lowercase == "off" || lowercase == "false")
+      return false;
+   // FIXME: Implement a wrapper around __builtin_unreachable() and use it here
+   return false;
+}
+
 } // namespace FoundationUtils
 } // namespace ROOT
diff --git a/core/foundation/test/CMakeLists.txt b/core/foundation/test/CMakeLists.txt
index 2665caf45fa..39b8587b6c6 100644
--- a/core/foundation/test/CMakeLists.txt
+++ b/core/foundation/test/CMakeLists.txt
@@ -8,3 +8,4 @@ ROOT_ADD_GTEST(testMake_unique testMake_unique.cxx LIBRARIES Core)
 ROOT_ADD_GTEST(testTypeTraits testTypeTraits.cxx LIBRARIES Core)
 ROOT_ADD_GTEST(testNotFn testNotFn.cxx LIBRARIES Core)
 ROOT_ADD_GTEST(testClassEdit testClassEdit.cxx LIBRARIES Core)
+ROOT_ADD_GTEST(FoundationUtilsTests FoundationUtilsTests.cxx LIBRARIES Core INCLUDE_DIRS ../res)
diff --git a/core/foundation/test/FoundationUtilsTests.cxx b/core/foundation/test/FoundationUtilsTests.cxx
new file mode 100644
index 00000000000..b7124b3dfe5
--- /dev/null
+++ b/core/foundation/test/FoundationUtilsTests.cxx
@@ -0,0 +1,51 @@
+/// \file FoundationUtilsTests.h
+///
+/// \brief The file contain unit tests which test the ROOT::FoundationUtils
+///
+/// \author Vassil Vassilev <vvasilev@cern.ch>
+///
+/// \date Jun, 2020
+///
+/*************************************************************************
+ * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include <ROOT/FoundationUtils.hxx>
+
+#include "gtest/gtest.h"
+
+using namespace ROOT::FoundationUtils;
+
+TEST(FoundationUtilsTests, CanConvertEnvValueToBool)
+{
+  ASSERT_TRUE(CanConvertEnvValueToBool("0"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("false"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("False"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("FALSE"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("Off"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("off"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("OFF"));
+
+  ASSERT_TRUE(CanConvertEnvValueToBool("1"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("true"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("True"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("TRUE"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("On"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("on"));
+  ASSERT_TRUE(CanConvertEnvValueToBool("ON"));
+}
+
+TEST(FoundationUtilsTests, ConvertEnvValueToBool)
+{
+  ASSERT_TRUE(ConvertEnvValueToBool("1"));
+  ASSERT_TRUE(ConvertEnvValueToBool("TruE"));
+  ASSERT_TRUE(ConvertEnvValueToBool("oN"));
+
+  ASSERT_FALSE(ConvertEnvValueToBool("0"));
+  ASSERT_FALSE(ConvertEnvValueToBool("FalSe"));
+  ASSERT_FALSE(ConvertEnvValueToBool("oFf"));
+}
diff --git a/core/metacling/src/TCling.cxx b/core/metacling/src/TCling.cxx
index db0da136200..9300f34f475 100644
--- a/core/metacling/src/TCling.cxx
+++ b/core/metacling/src/TCling.cxx
@@ -1221,11 +1221,16 @@ static void RegisterCxxModules(cling::Interpreter &clingInterp)
       // Conservatively enable platform by platform.
       bool supportedPlatform = false;
       // Allow forcefully enabling the GMI.
-      const char *experimentalGMI = gSystem->Getenv("ROOT_EXPERIMENTAL_GMI");
-      if (experimentalGMI && strcmp(experimentalGMI,"false") != 0)
+      llvm::Optional<std::string> EnvEnGMI = llvm::sys::Process::GetEnv("ROOT_EXPERIMENTAL_GMI");
+      if (EnvEnGMI.hasValue() && ROOT::FoundationUtils::ConvertEnvValueToBool(*EnvEnGMI))
          supportedPlatform = true;
 
-      if (supportedPlatform && !gSystem->Getenv("ROOT_DISABLE_GMI")) {
+      llvm::Optional<std::string> EnvDisGMI = llvm::sys::Process::GetEnv("ROOT_DISABLE_GMI");
+      if (EnvDisGMI.hasValue() && EnvEnGMI.hasValue())
+         ::Error("TCling__RegisterCxxModules",
+                 "Both ROOT_EXPERIMENTAL_GMI and ROOT_DISABLE_GMI env vars are set!");
+
+      if (supportedPlatform && EnvDisGMI.hasValue() && ROOT::FoundationUtils::ConvertEnvValueToBool(*EnvDisGMI)) {
          loadGlobalModuleIndex(SourceLocation(), clingInterp);
          // FIXME: The ASTReader still calls loadGlobalIndex and loads the file
          // We should investigate how to suppress it completely.

From b62d5667a1deecbbf0bd0dd6c967ba54369a8907 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Wed, 17 Jun 2020 05:38:29 +0000
Subject: [PATCH 2/7] [cxxmodules] Enable the semantic global module index to
 boost performance.

The global module index (GMI) is an optimization which hides the introduced by
clang overhead when pre-loading the C++ modules at startup.

The GMI represents a mapping between an identifier and a set of modules which
contain this indentifier. This mean that if we TH1 is undeclared the GMI will
load all modules which contain this identifier which is usually suboptimal, too.

The semantic GMI maps identifiers only to modules which contain a definition of
the entity behind the identifier. For cases such as typedefs where the entity
introduces a synonym (rather than declaration) we map the first module we
encounter. For namespaces we add all modules which has a namespace partition.
The namespace case is still suboptimal and further improved by inspecting
what exactly is being looked up in the namespace by the qualified lookup facilities.
---
 README/README.CXXMODULES.md                   | 62 ++++++++++++++-----
 core/dictgen/src/rootcling_impl.cxx           |  2 +
 core/foundation/test/FoundationUtilsTests.cxx |  1 +
 core/metacling/src/TCling.cxx                 | 34 ++++++----
 core/metacling/src/TClingCallbacks.cxx        |  9 ++-
 .../cling/lib/Interpreter/Interpreter.cpp     |  1 -
 6 files changed, 78 insertions(+), 31 deletions(-)

diff --git a/README/README.CXXMODULES.md b/README/README.CXXMODULES.md
index 09283e483f8..1a993d39400 100644
--- a/README/README.CXXMODULES.md
+++ b/README/README.CXXMODULES.md
@@ -309,10 +309,6 @@ different. There are several differences which can be noticed:
   * rootcling -cxxmodule creates a single artifact *Name.pcm* after the library
   name. At a final stage, ROOT might be able to integrate the Name.pcm with the
   shared library itself.
-  * Preloads all \*pcm files at start up time -- this currently is the only
-  remaining bottleneck which introduces a relatively small performance overhead
-  at startup time and is described bellow. It will be negligible for third-
-  party code (dominated by header parsing).
   * Improved correctness in number of cases -- in a few cases ROOT is more
   correct. In particular, when resolving global variables and function
   declarations which are not part of the ROOT PCH.
@@ -323,6 +319,21 @@ different. There are several differences which can be noticed:
   the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very
   efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol
   to be extended to system libraries.
+
+### Module Registration Approaches
+
+  The C++ modules system supports /*preloading*/ of all modules at startup time.
+  The current implementation of loading of C++ modules in clang has an overhead
+  and is between 40-60 MB depending on the ROOT configuration while there might
+  be 2x slowdown depending on the workflow. These issues are very likely to be
+  addressed by the LLVM community in midterm.
+
+  Preloading of all C++ modules is semantically the closest to C++ behavior.
+  However, in order to achieve performance ROOT loads them on demand using
+  a global module index file. It has sufficient information to map a looked up
+  identifier to the module which contains the corresponding definition. Switching
+  back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`
+  environment variable to false.
   
 ### Supported Platforms
 
@@ -349,14 +360,15 @@ different. There are several differences which can be noticed:
 
 ## State of the union
 
-C++ Modules-aware ROOT preloads all modules at start up time. Our motivating
-example:
+Preloading all modules at start up time turn our motivating example into:
 
 ```cpp
 // ROOT prompt
 root [] S *s;           // #1: does not require a definition.
 root [] foo::bar *baz1; // #2: does not require a definition.
 root [] foo::bar baz2;  // #3: requires a definition.
+root [] TCanvas* c = new TCanvas(); // #4 requires a definition
+
 ```
 
 becomes equivalent to
@@ -368,12 +380,29 @@ root [] import Foo.*;
 root [] S *s;           // #1: does not require a definition.
 root [] foo::bar *baz1; // #2: does not require a definition.
 root [] foo::bar baz2;  // #3: requires a definition.
+root [] TCanvas* c = new TCanvas(); // #4 requires a definition
 ```
 
 The implementation avoids recursive actions and relies on a well-defined (by
 the C++ standard) behavior. Currently, this comes with a constant performance
 overhead which we go in details bellow.
 
+ROOT uses the global module index (GMI) to avoid the performance overhead. ROOT
+only preloads the set of C++ modules which are not present in the GMI. The
+example becomes equivalent to:
+
+```cpp
+// ROOT prompt
+root [] import Foo.*;   // Preload Foo if it is not in the GMI.
+root [] S *s;           // #1: does not require a definition.
+root [] foo::bar *baz1; // #2: does not require a definition.
+root [] foo::bar baz2;  // #3: requires a definition.
+root [] TCanvas* c = new TCanvas(); // #4 requires a definition
+```
+
+Line #4 forces cling to send ROOT a callback that TCanvas in unknown but
+the GMI resolves it to module Gpad, loads it and returns the control to cling.
+
 
 ### Performance
 This section compares ROOT PCH technology with C++ Modules which is important but
@@ -385,16 +414,9 @@ is not available.
 The comparisons are to give a good metric when we are ready to switch ROOT to use
 C++ Modules by default. However, since it is essentially the same technology,
 optimizations of C++ Modules also affect the PCH. We have a few tricks up in
-the slaves to but they come with given trade-offs. For example, we can avoid
-preloading of all modules at the cost of introducing recursive behavior in
-loading. This requires to build a global module index which is an on-disk
-hash table. It will contain information about the mapping between an
-identifier and a module name. Upon failed identifier lookup we will use the
-map to decide which set of modules should be loaded. Another optimization
-includes building some of the modules without `-fmodules-local-submodule-visibility`.
-In turn, this would flatten the C++ modules structure and give us performance
-comparable to the ROOT PCH. The trade-off is that we will decrease the
-encapsulation and leak information about implementation-specific header files.
+the sleeves to but they come with given trade-offs.
+
+#### Preloading of C++ Modules
 
 The main focus for the technology preview was not in performance until recently.
 We have invested some resources in optimizations and we would like to show you
@@ -413,6 +435,14 @@ The performance is dependent on many factors such as configuration of ROOT and
 workflow. You can read more at our Intel IPCC-ROOT Showcase presentation
 here (pp 25-33)[[8]].
 
+#### Loading C++ Modules on Demand
+
+In long term, we should optimize the preloading of modules to be a no-op and
+avoid recursive behavior based on identifier lookup callbacks. Unfortunately,
+at the moment the loading of C++ modules on demand shows significantly better
+performance results.
+
+
 You can visit our continuous performance monitoring tool where we compare
 the performance of ROOT against ROOT with a PCH [[9]].
 *Note: if you get error 400, clean your cache or open a private browser session.*
diff --git a/core/dictgen/src/rootcling_impl.cxx b/core/dictgen/src/rootcling_impl.cxx
index 4ca67fdd1a1..5f1442fed1c 100644
--- a/core/dictgen/src/rootcling_impl.cxx
+++ b/core/dictgen/src/rootcling_impl.cxx
@@ -4325,6 +4325,8 @@ int RootClingMain(int argc,
                                       GetModuleNameFromRdictName(DepMod).str().data());
          }
          DepMod = GetModuleNameFromRdictName(DepMod);
+         // We might deserialize.
+         cling::Interpreter::PushTransactionRAII RAII(&interp);
          if (!interp.loadModule(DepMod, /*complain*/false)) {
             ROOT::TMetaUtils::Error(0, "Module '%s' failed to load.\n",
                                     DepMod.data());
diff --git a/core/foundation/test/FoundationUtilsTests.cxx b/core/foundation/test/FoundationUtilsTests.cxx
index b7124b3dfe5..75de502398c 100644
--- a/core/foundation/test/FoundationUtilsTests.cxx
+++ b/core/foundation/test/FoundationUtilsTests.cxx
@@ -22,6 +22,7 @@ using namespace ROOT::FoundationUtils;
 
 TEST(FoundationUtilsTests, CanConvertEnvValueToBool)
 {
+  ASSERT_FALSE(CanConvertEnvValueToBool(""));
   ASSERT_TRUE(CanConvertEnvValueToBool("0"));
   ASSERT_TRUE(CanConvertEnvValueToBool("false"));
   ASSERT_TRUE(CanConvertEnvValueToBool("False"));
diff --git a/core/metacling/src/TCling.cxx b/core/metacling/src/TCling.cxx
index 9300f34f475..811ba7bc9f0 100644
--- a/core/metacling/src/TCling.cxx
+++ b/core/metacling/src/TCling.cxx
@@ -1040,6 +1040,7 @@ static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp
       ::Info("TCling::__LoadModule", "Preloading module %s. \n",
              ModuleName.c_str());
 
+   cling::Interpreter::PushTransactionRAII deserRAII(&interp);
    return interp.loadModule(ModuleName, /*Complain=*/true);
 }
 
@@ -1219,18 +1220,27 @@ static void RegisterCxxModules(cling::Interpreter &clingInterp)
       clang::CompilerInstance &CI = *clingInterp.getCI();
       GlobalModuleIndex *GlobalIndex = nullptr;
       // Conservatively enable platform by platform.
-      bool supportedPlatform = false;
-      // Allow forcefully enabling the GMI.
-      llvm::Optional<std::string> EnvEnGMI = llvm::sys::Process::GetEnv("ROOT_EXPERIMENTAL_GMI");
-      if (EnvEnGMI.hasValue() && ROOT::FoundationUtils::ConvertEnvValueToBool(*EnvEnGMI))
-         supportedPlatform = true;
-
-      llvm::Optional<std::string> EnvDisGMI = llvm::sys::Process::GetEnv("ROOT_DISABLE_GMI");
-      if (EnvDisGMI.hasValue() && EnvEnGMI.hasValue())
-         ::Error("TCling__RegisterCxxModules",
-                 "Both ROOT_EXPERIMENTAL_GMI and ROOT_DISABLE_GMI env vars are set!");
-
-      if (supportedPlatform && EnvDisGMI.hasValue() && ROOT::FoundationUtils::ConvertEnvValueToBool(*EnvDisGMI)) {
+      bool supportedPlatform =
+#ifdef R__LINUX
+         true
+#elif defined(R__MACOSX)
+         true
+#else // Windows
+         false
+#endif
+         ;
+      // Allow forcefully enabling/disabling the GMI.
+      llvm::Optional<std::string> envUseGMI = llvm::sys::Process::GetEnv("ROOT_USE_GMI");
+      if (envUseGMI.hasValue()) {
+         bool value = envUseGMI->empty() || ROOT::FoundationUtils::ConvertEnvValueToBool(*envUseGMI);
+
+         if (supportedPlatform == value)
+            ::Warning("TCling__RegisterCxxModules", "Global module index is%sused already!",
+                     (value) ? " " :" not ");
+         supportedPlatform = value;
+      }
+
+      if (supportedPlatform) {
          loadGlobalModuleIndex(SourceLocation(), clingInterp);
          // FIXME: The ASTReader still calls loadGlobalIndex and loads the file
          // We should investigate how to suppress it completely.
diff --git a/core/metacling/src/TClingCallbacks.cxx b/core/metacling/src/TClingCallbacks.cxx
index 307469d5657..91384e7909c 100644
--- a/core/metacling/src/TClingCallbacks.cxx
+++ b/core/metacling/src/TClingCallbacks.cxx
@@ -11,6 +11,8 @@
 
 #include "TClingCallbacks.h"
 
+#include <ROOT/FoundationUtils.hxx>
+
 #include "cling/Interpreter/DynamicLibraryManager.h"
 #include "cling/Interpreter/Interpreter.h"
 #include "cling/Interpreter/InterpreterCallbacks.h"
@@ -38,6 +40,7 @@
 #include "llvm/Support/Error.h"
 #include "llvm/Support/FileSystem.h"
 #include "llvm/Support/Path.h"
+#include "llvm/Support/Process.h"
 
 #include "TClingUtils.h"
 #include "ClingRAII.h"
@@ -288,8 +291,10 @@ bool TClingCallbacks::LookupObject(LookupResult &R, Scope *S) {
 
 bool TClingCallbacks::findInGlobalModuleIndex(DeclarationName Name, bool loadFirstMatchOnly /*=true*/)
 {
-   if (::getenv("ROOT_DISABLE_GMI"))
-      return false;
+   llvm::Optional<std::string> envUseGMI = llvm::sys::Process::GetEnv("ROOT_USE_GMI");
+   if (envUseGMI.hasValue())
+      if (!envUseGMI->empty() && !ROOT::FoundationUtils::ConvertEnvValueToBool(*envUseGMI))
+         return false;
 
    const CompilerInstance *CI = m_Interpreter->getCI();
    const LangOptions &LangOpts = CI->getPreprocessor().getLangOpts();
diff --git a/interpreter/cling/lib/Interpreter/Interpreter.cpp b/interpreter/cling/lib/Interpreter/Interpreter.cpp
index 4ae8e45d737..6e7b022b5bf 100644
--- a/interpreter/cling/lib/Interpreter/Interpreter.cpp
+++ b/interpreter/cling/lib/Interpreter/Interpreter.cpp
@@ -883,7 +883,6 @@ namespace cling {
     Preprocessor& PP = getCI()->getPreprocessor();
     IdentifierInfo* II = PP.getIdentifierInfo(M->Name);
     SourceLocation ValidLoc = getNextAvailableLoc();
-    Interpreter::PushTransactionRAII RAII(this);
     bool success =
        !getSema().ActOnModuleImport(ValidLoc, ValidLoc,
                                     std::make_pair(II, ValidLoc)).isInvalid();

From d87977c2fd643fc557c59c47408716d306dc6ce2 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Wed, 8 Jul 2020 16:17:15 +0000
Subject: [PATCH 3/7] Try reduce the visitation

---
 core/metacling/src/TCling.cxx | 39 +++++++++++++++++++++++++++--------
 1 file changed, 30 insertions(+), 9 deletions(-)

diff --git a/core/metacling/src/TCling.cxx b/core/metacling/src/TCling.cxx
index 811ba7bc9f0..375779bae8e 100644
--- a/core/metacling/src/TCling.cxx
+++ b/core/metacling/src/TCling.cxx
@@ -1112,26 +1112,47 @@ static GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc, cling
          struct DefinitionFinder : public RecursiveASTVisitor<DefinitionFinder> {
             DefinitionFinder(clang::GlobalModuleIndex::UserDefinedInterestingIDs& IDs,
                              clang::TranslationUnitDecl* TU) : DefinitionIDs(IDs) {
-               TraverseDecl(TU);
-            }
-            bool VisitNamedDecl(NamedDecl *ND) {
-               for (auto R : ND->redecls()) {
-                  if (!R->isFromASTFile())
+               for (const Decl* D : TU->decls()) {
+                  if (!isa<NamedDecl>(D))
                      continue;
-                  if (TagDecl *TD = llvm::dyn_cast<TagDecl>(R)) {
+                  const NamedDecl* ND = cast<NamedDecl>(D);
+                  if (!ND->isFromASTFile())
+                     continue;
+
+                  if (const TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {
                      if (TD->isCompleteDefinition())
                         Register(TD);
-                  } else if (NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(R))
+                  } else if (const NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {
+                     // if (!NSD->getParent()->isTranslationUnit())
+                     //    return false;
                      Register(NSD, /*AddSingleEntry=*/ false);
-                  else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(R))
+                  }
+                  else if (const TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND))
                      Register(TND);
                   // FIXME: Add the rest...
                }
+               //TraverseDecl(TU);
+            }
+            bool VisitNamedDecl(NamedDecl *ND) {
+               if (!ND->isFromASTFile())
+                  return true; // Do not descend.
+
+               if (TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {
+                  if (TD->isCompleteDefinition())
+                     Register(TD);
+               } else if (NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {
+                  // if (!NSD->getParent()->isTranslationUnit())
+                  //    return false;
+                  Register(NSD, /*AddSingleEntry=*/ false);
+               }
+               else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND))
+                  Register(TND);
+               // FIXME: Add the rest...
                return true; // continue decending
             }
          private:
             clang::GlobalModuleIndex::UserDefinedInterestingIDs &DefinitionIDs;
-            void Register(NamedDecl* ND, bool AddSingleEntry = true) {
+            void Register(const NamedDecl* ND, bool AddSingleEntry = true) {
                assert(ND->isFromASTFile());
                // FIXME: All decls should have an owning module once rootcling
                // updates its generated decls from within the LookupHelper & co.

From 73abcbb06b2b67b8fc9116e57b9f861140dacbab Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Thu, 9 Jul 2020 09:51:49 +0000
Subject: [PATCH 4/7] Allow the first not yet loaded module only.

---
 core/metacling/src/TClingCallbacks.cxx        | 20 ++++++++++++++-----
 core/metacling/src/TClingCallbacks.h          |  1 +
 .../clang/Serialization/GlobalModuleIndex.h   |  2 +-
 .../lib/Serialization/GlobalModuleIndex.cpp   |  2 +-
 4 files changed, 18 insertions(+), 7 deletions(-)

diff --git a/core/metacling/src/TClingCallbacks.cxx b/core/metacling/src/TClingCallbacks.cxx
index 91384e7909c..102f09ac69c 100644
--- a/core/metacling/src/TClingCallbacks.cxx
+++ b/core/metacling/src/TClingCallbacks.cxx
@@ -320,15 +320,25 @@ bool TClingCallbacks::findInGlobalModuleIndex(DeclarationName Name, bool loadFir
    // Find the modules that reference the identifier.
    // Note that this only finds top-level modules.
    if (Index->lookupIdentifier(Name.getAsString(), FoundModules)) {
-      for (auto FileName : FoundModules) {
-         StringRef ModuleName = llvm::sys::path::stem(*FileName);
+      for (llvm::StringRef FileName : FoundModules) {
+         StringRef ModuleName = llvm::sys::path::stem(FileName);
+
+         // Skip to the first not-yet-loaded module.
+         if (m_LoadedModuleFiles.count(FileName)) {
+            if (gDebug > 2)
+               llvm::errs() << "Module '" << ModuleName << "' already loaded"
+                            << " for '" << Name.getAsString() << "'\n";
+            continue;
+         }
+
          fIsLoadingModule = true;
          if (gDebug > 2)
-            llvm::errs() << "Loading " << ModuleName << " on demand"
-                         << " for " << Name.getAsString() << "\n";
+            llvm::errs() << "Loading '" << ModuleName << "' on demand"
+                         << " for '" << Name.getAsString() << "'\n";
 
          m_Interpreter->loadModule(ModuleName);
          fIsLoadingModule = false;
+         m_LoadedModuleFiles[FileName] = Name;
          if (loadFirstMatchOnly)
             break;
       }
@@ -349,7 +359,7 @@ bool TClingCallbacks::LookupObject(const DeclContext* DC, DeclarationName Name)
    if (fIsAutoParsingSuspended || fIsAutoLoadingRecursively)
       return false;
 
-   if (findInGlobalModuleIndex(Name, /*loadFirstMatchOnly*/ false))
+   if (findInGlobalModuleIndex(Name, /*loadFirstMatchOnly*/ true))
       return true;
 
    if (Name.getNameKind() != DeclarationName::Identifier)
diff --git a/core/metacling/src/TClingCallbacks.h b/core/metacling/src/TClingCallbacks.h
index 797a49d9bf4..2179611ae4f 100644
--- a/core/metacling/src/TClingCallbacks.h
+++ b/core/metacling/src/TClingCallbacks.h
@@ -49,6 +49,7 @@ class TClingCallbacks : public cling::InterpreterCallbacks {
    bool fPPChanged = false;
    bool fIsCodeGening = false;
    bool fIsLoadingModule = false;
+   llvm::DenseMap<llvm::StringRef, clang::DeclarationName> m_LoadedModuleFiles;
 
 public:
    TClingCallbacks(cling::Interpreter* interp, bool hasCodeGen);
diff --git a/interpreter/llvm/src/tools/clang/include/clang/Serialization/GlobalModuleIndex.h b/interpreter/llvm/src/tools/clang/include/clang/Serialization/GlobalModuleIndex.h
index 0db0f5904da..d774a08d2d4 100644
--- a/interpreter/llvm/src/tools/clang/include/clang/Serialization/GlobalModuleIndex.h
+++ b/interpreter/llvm/src/tools/clang/include/clang/Serialization/GlobalModuleIndex.h
@@ -186,7 +186,7 @@ class GlobalModuleIndex {
   /// \returns true if the identifier is known to the index, false otherwise.
   bool lookupIdentifier(StringRef Name, HitSet &Hits);
 
-  typedef llvm::SmallPtrSet<std::string *, 4> FileNameHitSet;
+  typedef llvm::SmallDenseSet<llvm::StringRef, 4> FileNameHitSet;
   bool lookupIdentifier(StringRef Name, FileNameHitSet &Hits);
 
   /// \brief Note that the given module file has been loaded.
diff --git a/interpreter/llvm/src/tools/clang/lib/Serialization/GlobalModuleIndex.cpp b/interpreter/llvm/src/tools/clang/lib/Serialization/GlobalModuleIndex.cpp
index 7406342fd2a..09b366d78bf 100644
--- a/interpreter/llvm/src/tools/clang/lib/Serialization/GlobalModuleIndex.cpp
+++ b/interpreter/llvm/src/tools/clang/lib/Serialization/GlobalModuleIndex.cpp
@@ -339,7 +339,7 @@ bool GlobalModuleIndex::lookupIdentifier(StringRef Name, FileNameHitSet &Hits) {
   SmallVector<unsigned, 2> ModuleIDs = *Known;
   for (unsigned I = 0, N = ModuleIDs.size(); I != N; ++I) {
     assert(!Modules[ModuleIDs[I]].FileName.empty());
-    Hits.insert(&Modules[ModuleIDs[I]].FileName);
+    Hits.insert(Modules[ModuleIDs[I]].FileName);
   }
 
   ++NumIdentifierLookupHits;

From ab4f01a1a01016df2df56cbaf1b4c34943024097 Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Fri, 10 Jul 2020 19:17:03 +0000
Subject: [PATCH 5/7] Visit deeper again.

---
 core/metacling/src/TCling.cxx | 44 +++++++++++++++++------------------
 1 file changed, 21 insertions(+), 23 deletions(-)

diff --git a/core/metacling/src/TCling.cxx b/core/metacling/src/TCling.cxx
index 375779bae8e..6422d0b668c 100644
--- a/core/metacling/src/TCling.cxx
+++ b/core/metacling/src/TCling.cxx
@@ -1112,37 +1112,35 @@ static GlobalModuleIndex *loadGlobalModuleIndex(SourceLocation TriggerLoc, cling
          struct DefinitionFinder : public RecursiveASTVisitor<DefinitionFinder> {
             DefinitionFinder(clang::GlobalModuleIndex::UserDefinedInterestingIDs& IDs,
                              clang::TranslationUnitDecl* TU) : DefinitionIDs(IDs) {
-               for (const Decl* D : TU->decls()) {
-                  if (!isa<NamedDecl>(D))
-                     continue;
-                  const NamedDecl* ND = cast<NamedDecl>(D);
-                  if (!ND->isFromASTFile())
-                     continue;
-
-                  if (const TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {
-                     if (TD->isCompleteDefinition())
-                        Register(TD);
-                  } else if (const NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {
-                     // if (!NSD->getParent()->isTranslationUnit())
-                     //    return false;
-                     Register(NSD, /*AddSingleEntry=*/ false);
-                  }
-                  else if (const TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND))
-                     Register(TND);
-                  // FIXME: Add the rest...
-               }
-               //TraverseDecl(TU);
+               // for (const Decl* D : TU->decls()) {
+               //    if (!isa<NamedDecl>(D))
+               //       continue;
+               //    const NamedDecl* ND = cast<NamedDecl>(D);
+               //    if (!ND->isFromASTFile())
+               //       continue;
+
+               //    if (const TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {
+               //       if (TD->isCompleteDefinition())
+               //          Register(TD);
+               //    } else if (const NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {
+               //       // if (!NSD->getParent()->isTranslationUnit())
+               //       //    return false;
+               //       Register(NSD, /*AddSingleEntry=*/ false);
+               //    }
+               //    else if (const TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND))
+               //       Register(TND);
+               //    // FIXME: Add the rest...
+               // }
+               TraverseDecl(TU);
             }
             bool VisitNamedDecl(NamedDecl *ND) {
                if (!ND->isFromASTFile())
-                  return true; // Do not descend.
+                  return true;
 
                if (TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {
                   if (TD->isCompleteDefinition())
                      Register(TD);
                } else if (NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {
-                  // if (!NSD->getParent()->isTranslationUnit())
-                  //    return false;
                   Register(NSD, /*AddSingleEntry=*/ false);
                }
                else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND))

From d21e046bc4c8c90f512c24f97a18bdc3bfc043cb Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Tue, 14 Jul 2020 20:16:10 +0000
Subject: [PATCH 6/7] Might deserialize

---
 core/metacling/src/TClingDataMemberInfo.cxx | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/core/metacling/src/TClingDataMemberInfo.cxx b/core/metacling/src/TClingDataMemberInfo.cxx
index c821dfe2a54..49c17d6d6dd 100644
--- a/core/metacling/src/TClingDataMemberInfo.cxx
+++ b/core/metacling/src/TClingDataMemberInfo.cxx
@@ -442,6 +442,8 @@ long TClingDataMemberInfo::Property() const
    property = TClingDeclInfo::Property(property, qt);
    const clang::TagType *tt = qt->getAs<clang::TagType>();
    if (tt) {
+      // tt->getDecl() might deserialize.
+      cling::Interpreter::PushTransactionRAII RAII(fInterp);
       const clang::TagDecl *td = tt->getDecl();
       if (td->isClass()) {
          property |= kIsClass;

From 8de1570dff01d75fd5758d8c9a08b0cab876da6a Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Wed, 15 Jul 2020 09:03:18 +0000
Subject: [PATCH 7/7] Might deserialize2

---
 core/metacling/src/TCling.cxx | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/core/metacling/src/TCling.cxx b/core/metacling/src/TCling.cxx
index 6422d0b668c..a0d6c5e547b 100644
--- a/core/metacling/src/TCling.cxx
+++ b/core/metacling/src/TCling.cxx
@@ -2914,6 +2914,8 @@ void TCling::InspectMembers(TMemberInspector& insp, const void* obj,
    // inspect bases
    // TNamed::ShowMembers(R__insp);
    unsigned iNBase = 0;
+   // Iteration over base classes might deserialize.
+   cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());
    for (clang::CXXRecordDecl::base_class_const_iterator iBase
         = recordDecl->bases_begin(), eBase = recordDecl->bases_end();
         iBase != eBase; ++iBase, ++iNBase) {
